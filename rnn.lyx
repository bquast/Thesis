#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{appendix}
\usepackage[style=philosophy-modern,natbib=true,backend=biber]{biblatex}
\addbibresource{/Users/quast/Thesis/bibliography.bib}
\end_preamble
\use_default_options true
\begin_modules
knitr
logicalmkup
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Provides natbib 1
\end_local_layout
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command biber
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_author "Bastiaan Quast"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rnn
\end_layout

\end_inset

: a Recurrent Neural Network in R
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
https://cran.r-project.org/package=rnn | https://github.com/bquast/rnn
\end_layout

\end_inset


\end_layout

\begin_layout Author
Bastiaan Quast
\begin_inset Foot
status open

\begin_layout Plain Layout
http://qua.st | bastiaan.quast@graduateinstitute.ch | bquast@gmail.com
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Abstract
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rnn
\end_layout

\end_inset

 package implements the first Recurrent Neural Network (RNN) in the R language.
 RNN algorithms expand on traditional feed-forward neural networks, allowing
 for greater complexity and dynamics, by implementing a memory state.
 This temporal nature of the algorithm makes it explicitly well suited for
 dynamic problems such as time series prediction.
 Additionally, this also allows for inputs of undefined or changing length,
 allowing models to be updated as new data comes in.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rnn
\end_layout

\end_inset

 package is the first implementation of a Recurrent Neural Network in the
 R language, making it both operable and understandable to R users.
 Here I apply the package to two problems, the classic complex problem of
 carrying a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

, in bit by bit (column by column) binary addition, as well as foreign exchange
 rate prediction.
 Interactive live versions of these examples are available on my website
 http://qua.st/rnn.
\end_layout

\begin_layout Abstract
\begin_inset Note Note
status open

\begin_layout Plain Layout
explicitly moving outside of the realm of computer science, where it originated.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
setup, echo=FALSE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.path='figure/latex-',
\end_layout

\begin_layout Plain Layout

cache.path='cache/latex-',
\end_layout

\begin_layout Plain Layout

fig.width=9,
\end_layout

\begin_layout Plain Layout

fig.height=5)
\end_layout

\end_inset

This package implements the first Recurrent Neural Network in the R language.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
only makes use of base R functions, very easy to understand process
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
which is trained to sum two (or more) binary numbers, teaching itself the
 complex task of carrying a 1 over to the next iteration if the sum of a
 column takes two bits of space.
\end_layout

\begin_layout Plain Layout
to convert numbers in range of 0-127 to binary representation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
mention existing R packages, nnet, caret, and RSNNS
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
mention RNN work in python
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Of course, numbers < 128 can be represent in a 7-bit binary form, but since
 we are adding two numbers in the range 0-127, the total can reach and achieve
 128, which requires 8 bits, it cannot be more than 254, the limit of 8
 bit binary representation is 255, thereby preventing overflows.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At this point it is useful to clarify the nomenclature in this article.
 I use the term RNN (capitalised) for the general concept of a Recurrent
 Neural Network and I use 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rnn
\end_layout

\end_inset

 (in minuscules and using a monospace font) to refer to the R package.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rnn
\end_layout

\end_inset

 Package
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
library
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# load library
\end_layout

\begin_layout Plain Layout

library(rnn)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# list included functions
\end_layout

\begin_layout Plain Layout

ls('package:rnn')
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As is listed above, the package contains the following functions:
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
bin2int()
\end_layout

\end_inset

: conversion of a matrix of numbers in binary representation to decimal
 representation;
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
int2bin()
\end_layout

\end_inset

: conversion of a vector numbers in decimal representation to binary representat
ion;
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictr()
\end_layout

\end_inset

: predicts response variable based on a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 model and input data;
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

: primary function, trains a model based on training data and hyperparameters.
\end_layout

\begin_layout Standard
In addition to these functions there are also two internal functions 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
i2b()
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
b2i()
\end_layout

\end_inset

, these functions are used by 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
int2bin()
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
bin2int()
\end_layout

\end_inset

 internally to change a single number from decimal to binary or visa versa.
\end_layout

\begin_layout Standard
The main 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 function takes two arrays as inputs, the response variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

 and the input variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

, it returns a model that can be used with by the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictr()
\end_layout

\end_inset

 function together with a testing data input array 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Internally, the functions make use of one or more sigmoid functions.
 In order to make the Sigmoid functions more generally available, these
 were moved to a separate package 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sigmoid
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
sigmoid
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
sigmoid
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# load library
\end_layout

\begin_layout Plain Layout

library(sigmoid)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# list included functions
\end_layout

\begin_layout Plain Layout

ls('package:sigmoid')
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sigmoid()
\end_layout

\end_inset

 function is a wrapper, that defaults to the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
logistic()
\end_layout

\end_inset

 function, which maps the inputs to (0,1) using the logistic function, when
 using the default parameters, this is the standard logistic function.
\end_layout

\begin_layout Section
Data
\end_layout

\begin_layout Subsection
Binary Addition
\end_layout

\begin_layout Standard
The vectors 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

 are independent variables, the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

 vector is the sum of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

 and acts as the response variable (for more info see 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
help('trainr')
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Training data can be generated using 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
base
\end_layout

\end_inset

 package's 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sample()
\end_layout

\end_inset

 function.
 For reproducibility, we also set the seed value of the pseudo-random number
 generator that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
R
\end_layout

\end_inset

 uses internally to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

.
 After generating 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

, I add the two pairwise and store the result in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

.
 Finally, I convert both the input variables and the response variable to
 binary representation using the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
int2bin()
\end_layout

\end_inset

 included with the package.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Binary Numbers
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
binary_data, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# use the same random numbers
\end_layout

\begin_layout Plain Layout

set.seed(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# create training inputs 
\end_layout

\begin_layout Plain Layout

X1 = sample(0:127, 7000, replace=TRUE) 
\end_layout

\begin_layout Plain Layout

X2 = sample(0:127, 7000, replace=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# create training output 
\end_layout

\begin_layout Plain Layout

Y <- X1 + X2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Internally the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
int2bin()
\end_layout

\end_inset

 function converts these characters into binary format using the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
intToBits()
\end_layout

\end_inset

 function, the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
bin2int()
\end_layout

\end_inset

 function converts it back into decimal format for printing using the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
packBits()
\end_layout

\end_inset

 function, both functions are included in the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
base
\end_layout

\end_inset

 package.
\end_layout

\begin_layout Standard
We can for instance take the first value of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and convert it to a binary representation, whereby the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
binary_dim
\end_layout

\end_inset

 argument to the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 function determines the length of the binary representation, throughout
 this paper we will use 8 bit representations (which limits numbers to the
 range 0-255), but the theoretical limit is 32 bits.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Binary Representation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
int2bin, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

int2bin( X1[1] )
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lets check look at the first sum in decimal representation.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Decimal Summation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
decimal_rep, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

X1[1]
\end_layout

\begin_layout Plain Layout

X2[1]
\end_layout

\begin_layout Plain Layout

X1[1] + X2[1]
\end_layout

\begin_layout Plain Layout

Y[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
and now in binary representation.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Binary Summation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
binary_rep, results='hold', cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

int2bin( X1[1] )
\end_layout

\begin_layout Plain Layout

int2bin( X2[1] )
\end_layout

\begin_layout Plain Layout

print('--------------------------------------')
\end_layout

\begin_layout Plain Layout

int2bin( Y[1]  )
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen from the above output, the first values of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
33
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
89
\end_layout

\end_inset

 respectively, are both in the range 0-127, which can be represented with
 only 7 bits.
 Yet the sum of the two - 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
122
\end_layout

\end_inset

 - is almost outside of the range 0-127, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
which is why an 8th bit is required (i.e.
 the 8th value from right to left in the bottom row is 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

)
\end_layout

\end_inset

.
 If we sampled numbers great than 127 for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

 then the sum of the two could be greater than 255, which requires a ninth
 bit (or 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
length=9
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
We can now convert the entire vectors to binary matrices.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
int2bin_all, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# convert to binaries of 8 bit (default)
\end_layout

\begin_layout Plain Layout

X1 <- int2bin(X1)
\end_layout

\begin_layout Plain Layout

X2 <- int2bin(X2)
\end_layout

\begin_layout Plain Layout

Y  <- int2bin(Y)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Array Form
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

array form, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# create 3d array: dim 1: samples; dim 2: time; dim 3: variables
\end_layout

\begin_layout Plain Layout

X <- array( c(X1,X2), dim=c(dim(X1),2) )
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Foreign Exchange Prediction
\end_layout

\begin_layout Standard
In this second example I train a RNN on more real-life data.
 I use the exchange rates of four major international currencies against
 the US Dollar.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Foreign Exchange Data
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
quantmod, message=FALSE, warning=FALSE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

library(quantmod) # for downloading FX data
\end_layout

\begin_layout Plain Layout

start = '1998-12-14'
\end_layout

\begin_layout Plain Layout

end   = '2001-09-01'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# download values
\end_layout

\begin_layout Plain Layout

# output is automatically returned to
\end_layout

\begin_layout Plain Layout

# the global environment (.GlobalEnv)
\end_layout

\begin_layout Plain Layout

getFX('CHF/USD', from = start, to = end)
\end_layout

\begin_layout Plain Layout

getFX('GBP/USD', from = start, to = end)
\end_layout

\begin_layout Plain Layout

getFX('JPY/USD', from = start, to = end)
\end_layout

\begin_layout Plain Layout

getFX('EUR/USD', from = start, to = end)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Input data should be on the domain [0,1].
 Exchange rates are well suited for this since either A/B or B/A has to
 be in this domain.
 However, it is of course possible that within the time period studied,
 currency A, initially being worth less than currency B, becomes worth more.
 This is exactly what happened with the EUR/USD exchange rate.
 This means that neither EUR/USD nor USD/EUR is within the [0,1] domain
 for the entire period.
\end_layout

\begin_layout Standard
It is for this reason that sigmoid functions are used to map any real number
 to the domain [0,1].
 The most function for this is the logistic function.
 At the end of the process, the outputs are mapped again to the original
 domain, using the inverse of the sigmoid function, in the case of the logistic,
 this is the logit function.
\end_layout

\begin_layout Standard
By specifying the x0.
\end_layout

\begin_layout Section
Methodology
\end_layout

\begin_layout Standard
The workhorse of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rnn
\end_layout

\end_inset

 package is the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
For example, if we add the binary numbers 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0 0 1
\end_layout

\end_inset

 (decimal system: 1) and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1 0 1
\end_layout

\end_inset

 (decimal system: 5), we start by adding the right column, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 make 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1 0
\end_layout

\end_inset

 (similar to when 5 and 5 make 1 0 in the decimal system) , the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

 is stored in the right column, the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 is carried over to the middle column and added with the two existing bits
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

, to form 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

, which is stored in the middle column.
 This time nothing is carried over and the left column sums 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 to make 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

, which gives the outcome 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1 1 0
\end_layout

\end_inset

 (decimal system: 6).
\end_layout

\begin_layout Standard
If we go back to the output of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
int2bin()
\end_layout

\end_inset

 function for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

, and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Y
\end_layout

\end_inset

, we see that in the 4th column (from right to left), a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

 and a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

 are added, resulting in an output of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

.
 This is because in the previous iteration 3rd column (from right to left)
 a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 and a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 are added, which becomes 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1 0
\end_layout

\end_inset

, so the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

 goes into column 3 and the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 is carried over to column 4.
 Since the summation is done bit by bit (or column by column), the neural
 network need to remember from the 3rd iteration until the 4th iteration
 that it is carrying a 1 over.
 It is this remembering that a feed-forward neural network cannot teach
 itself.
\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictr()
\end_layout

\end_inset

 functions internally make use of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sigmoid()
\end_layout

\end_inset

 function, specifically the standard logistic function, which takes the
 range (-Infinity, Infinity) and maps it to the range (0, 1).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logistic Source Code
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
print_logistic
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# print arguments to the function
\end_layout

\begin_layout Plain Layout

args(logistic)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# print source code of the logistic function
\end_layout

\begin_layout Plain Layout

logistic
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
For instance:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logistic Examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
demonstrate_logistic, results='hold'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

logistic(-137)
\end_layout

\begin_layout Plain Layout

logistic(5.3)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rough shape of the sigmoid function is shown below.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logistic Shape
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
logistic_shape, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

library(ggplot2) # load plotting package
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# sequence of -10 through 10
\end_layout

\begin_layout Plain Layout

x = seq(-10, 10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# plot sigmoid shape
\end_layout

\begin_layout Plain Layout

qplot(x = x, y = logistic(x), geom='line')
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binary Addition
\end_layout

\begin_layout Subsection
Foreign Exchange Prediction
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Logistic Mapping FX
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
logistic_map_bin, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# logistic map, write to new objects
\end_layout

\begin_layout Plain Layout

chfusd <- logistic(CHFUSD, k=sd(CHFUSD)^-1, x0=mean(CHFUSD) )
\end_layout

\begin_layout Plain Layout

gbpusd <- logistic(GBPUSD, k=sd(GBPUSD)^-1, x0=mean(GBPUSD) )
\end_layout

\begin_layout Plain Layout

jpyusd <- logistic(JPYUSD, k=sd(JPYUSD)^-1, x0=mean(JPYUSD) )
\end_layout

\begin_layout Plain Layout

eurusd <- logistic(EURUSD, k=sd(EURUSD)^-1, x0=mean(EURUSD) )
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Additionally the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictr()
\end_layout

\end_inset

 functions use the sigmoid_output_to_derivative() function.
\end_layout

\begin_layout Plain Layout
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Sigmoid Derivative Source Code
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
print_sigmoid_derivative
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# print source code of the sigmoid_output_to_derivate function
\end_layout

\begin_layout Plain Layout

sigmoid_output_to_derivative
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As the purpose of the package is to illustrate the working of a Recurrent
 Neural Network, the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 function is quite verbose (this can be controlled using the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
print
\end_layout

\end_inset

 argument).
\end_layout

\begin_layout Plain Layout
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
trainr() Output
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
trainr_output_full, size='tiny', echo=FALSE, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# use the same random numbers
\end_layout

\begin_layout Plain Layout

set.seed(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# create training inputs
\end_layout

\begin_layout Plain Layout

A1 = sample(0:127, 1000, replace=TRUE)
\end_layout

\begin_layout Plain Layout

A2 = sample(0:127, 1000, replace=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# create training output
\end_layout

\begin_layout Plain Layout

B <- A1 + A2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# train the network
\end_layout

\begin_layout Plain Layout

m0 <- trainr(B,
\end_layout

\begin_layout Plain Layout

             A,
\end_layout

\begin_layout Plain Layout

             hidden_dim =  3,
\end_layout

\begin_layout Plain Layout

			 numepochs  = 10)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 function will run until it has evaluated all rows in the matrices that
 it is fed and repeat this according to the number of epochs specified in
 the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
numepochs
\end_layout

\end_inset

 argument.
 Since the training of the network, particularly the carrying part, takes
 many iterations to learn (the exact number of iterations varies but depends
 on the hyperparameters, more on this in the next section), it is therefore
 advisable to sample several thousand values (I use 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
7000
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
The text printed here is of the 8 steps of the summation of the 1000th value
 of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

, or iteration 7993-8000.
\end_layout

\begin_layout Standard
Each iteration is printed individually, with the two input bits, the prediction
 for the response value and the actual response value.
\end_layout

\begin_layout Standard
After each iteration the difference between the predicted value and the
 actual value is fed back into the neural network using a method called
 back-propagation (an application the chain rule of differential calculus).
\end_layout

\begin_layout Standard
At the end of the 8 iterations that it here takes to add two values of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
X2
\end_layout

\end_inset

, the results are printed in a more human legible form.
 It should be clear from the results that after 1000 numbers, with 8 iterations
 each, the model is still performing very poorly.
\end_layout

\begin_layout Standard
However, progress can be observed:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
trainr() Output
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
trainr_output_minimal, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# train the network
\end_layout

\begin_layout Plain Layout

m1 <- trainr(Y,
\end_layout

\begin_layout Plain Layout

             X,
\end_layout

\begin_layout Plain Layout

             hidden_dim     =  5,
\end_layout

\begin_layout Plain Layout

             numepochs      = 10,
\end_layout

\begin_layout Plain Layout

             learningrate   =  0.1,
\end_layout

\begin_layout Plain Layout

             start_from_end = TRUE)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In fact, from the 6000th summation on, all the printed estimates are in
 fact correct.
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
The eventual purpose is to use the model generated by the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 function as an input to the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictr()
\end_layout

\end_inset

 function, in order to predict the values of new inputs.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Test Data
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
test_data, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# create test inputs
\end_layout

\begin_layout Plain Layout

C1 = int2bin( sample(0:127, 7000, replace=TRUE) )
\end_layout

\begin_layout Plain Layout

C2 = int2bin( sample(0:127, 7000, replace=TRUE) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# stack matrices in array
\end_layout

\begin_layout Plain Layout

C <- array( c(C1,C2), dim=c(dim(C1),2) )
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now predict using the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictr() 
\end_layout

\end_inset

function.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
predictr()
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
predictr, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# predict
\end_layout

\begin_layout Plain Layout

D  <- predictr(m1,
\end_layout

\begin_layout Plain Layout

               C  )
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now convert the predictions and the inputs back to decimals and plot
 them.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Evaluate Predictions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
qplot, cache=TRUE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

# convert back to decimal
\end_layout

\begin_layout Plain Layout

C1 <- bin2int(C[,,1])
\end_layout

\begin_layout Plain Layout

C2 <- bin2int(C[,,2])
\end_layout

\begin_layout Plain Layout

D  <- bin2int(D)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# inspect the differences               
\end_layout

\begin_layout Plain Layout

qplot( D - (C1+C2) )
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen from the results, the difference is almost always 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
0
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
CRAN and the rest of the R ecosystem show that there is a strong interest
 in using the R language for neural network analysis.
 Existing package such as the built in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
nnet
\end_layout

\end_inset

 package and the caret package make available very powerful neural network
 tools to R users.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RSNNS
\end_layout

\end_inset

 package acts as an R wrapper for the Stuttgart Neural Network Simulator
 library, which is written in C, and thereby makes available to partial
 RNNs such as Elman and Jordan networks.
\end_layout

\begin_layout Standard
The enormous popularity of full Recurrent Neural Networks in other languages,
 primarily Python and C, show that there is a great amount of interest for
 using this methodology, including interest from Economist, Data Scientists,
 and other non-professional programmers.
 Although Python is a relatively accessible programming language for laymen,
 it has a smaller user base in terms of data analysts.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rnn
\end_layout

\end_inset

 package attempts to address this need by showing that Recurrent Neural
 Networks can be made available and perhaps more importantly, made available
 in native R, which allows user to delve into the code and understand the
 method and developer a more thorough understanding of how to use it.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Source code of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
trainr()
\end_layout

\end_inset

 function
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/Users/quast/rnn/R/trainr.R"
lstparams "language=S,basicstyle={\\footnotesize},numbers=left,numberstyle={\\tiny},frame=single,breaklines=true,title={\\lstname}"

\end_inset


\end_layout

\begin_layout Section
Source code of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
predictr() 
\end_layout

\end_inset

function
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/Users/quast/rnn/R/predictr.R"
lstparams "language=S,basicstyle={\\footnotesize},numbers=left,numberstyle={\\tiny},frame=single,breaklines=true,title={\\lstname}"

\end_inset


\end_layout

\end_body
\end_document
